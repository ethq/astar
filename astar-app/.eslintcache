[{"F:\\GitHub\\astar\\astar-app\\src\\index.js":"1","F:\\GitHub\\astar\\astar-app\\src\\components\\AstarGrid.component.js":"2","F:\\GitHub\\astar\\astar-app\\src\\libs\\astar.js":"3","F:\\GitHub\\astar\\astar-app\\src\\libs\\grid.js":"4","F:\\GitHub\\astar\\astar-app\\src\\libs\\heap.js":"5","F:\\GitHub\\astar\\astar-app\\src\\libs\\util.js":"6"},{"size":379,"mtime":1610092995845,"results":"7","hashOfConfig":"8"},{"size":17919,"mtime":1610111619629,"results":"9","hashOfConfig":"8"},{"size":4511,"mtime":1610026795721,"results":"10","hashOfConfig":"8"},{"size":8167,"mtime":1610092995846,"results":"11","hashOfConfig":"8"},{"size":1788,"mtime":1610026795721,"results":"12","hashOfConfig":"8"},{"size":583,"mtime":1610092995846,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"1jpzm82",{"filePath":"17","messages":"18","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"19","messages":"20","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"21","usedDeprecatedRules":"16"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"16"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"27","messages":"28","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"F:\\GitHub\\astar\\astar-app\\src\\index.js",[],["29","30"],"F:\\GitHub\\astar\\astar-app\\src\\components\\AstarGrid.component.js",["31","32"],"F:\\GitHub\\astar\\astar-app\\src\\libs\\astar.js",["33","34"],"import MinHeap from './heap.js'\r\n\r\n// Simple helpers to manipulate arrays. Does NOT work for b shorter than a\r\nconst addVec = (a, b) => a.map((v, i) => v + b[i]);\r\nconst subVec = (a, b) => a.map((v, i) => v - b[i]);\r\n\r\n// For A* we'd like to calculate distances the same way, no matter the dimensions of the grid\r\nconst makeNodeDistance = (dimensions) => {\r\n\t// Width of grid cubes in each dimension\r\n\tconst widths = [dimensions.sizeX / dimensions.nCubesX,\r\n\t\t\t\t\tdimensions.sizeY / dimensions.nCubesY,\r\n\t\t\t\t\tdimensions.sizeZ / dimensions.nCubesZ];\r\n\t\r\n\treturn (nodeA, nodeB) => {\r\n\t\tconst posA = nodeA.cube.position.get();\r\n\t\tconst posB = nodeB.cube.position.get();\r\n\t\t\r\n\t\t// Distances, with a unit between each adjacent grid cell\r\n\t\tlet dists = subVec(posA, posB).map((v,i) => Math.abs(v)/widths[i]);\r\n\t\t\r\n\t\t// Distances on our unit grid, scaled by a factor 10 to avoid decimals\r\n\t\tconst distDiag = 14;\r\n\t\tconst distDirect = 10;\r\n\t\t\r\n\t\t// Dimensions to preferentially reduce in. [0, 1, 2] <=> [x, y, z]. dimA reduced first, then dimB. last moves are done in a straight line in dimC\r\n\t\tconst dimA = 0;\r\n\t\tconst dimB = 2;\r\n\t\t//const dimC = 1;\r\n\t\t\r\n\t\tconst distDiagAB = Math.min(dists[dimA], dists[dimB]);\r\n\t\tconst distDirectAB = Math.abs(dists[dimA] - dists[dimB]);\r\n\t\t\r\n\t\t// The diagonal moves are removed from both dimensions\r\n\t\tdists[dimA] -= distDiagAB;\r\n\t\tdists[dimB] -= distDiagAB;\r\n\t\t\r\n\t\t// The direct moves are removed from the largest dimension\r\n\t\tif (dists[dimA] > dists[dimB]) {\r\n\t\t\tdists[dimA] -= distDirectAB;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdists[dimB] -= distDirectAB;\r\n\t\t}\r\n\t\t\r\n\t\t// At this point dist = [0, Y, 0]\r\n\t\tconst distDiagABC = Math.min(Math.max(dists[dimA], dists[dimB]));\r\n\t\tconst distDirectABC = Math.abs(dists.reduce((a, cv) => a - cv));\r\n\t\t\r\n\t\t/*\r\n\t\tconsole.log(distDiagAB);\r\n\t\tconsole.log(distDirectAB);\r\n\t\tconsole.log(distDiagABC);\r\n\t\tconsole.log(distDirectABC);\r\n\t\t*/\r\n\t\t\r\n\t\treturn distDiag*(distDiagAB + distDiagABC) + distDirect*(distDirectAB + distDirectABC);\r\n\t};\r\n};\r\n\r\n// Apply some action to each node on the path\r\nconst retracePath = (node, apply) => {\r\n\tlet cnode = node.parent;\r\n\twhile(cnode.parent) {\r\n\t\tif (apply) {\r\n\t\t\tapply(cnode);\r\n\t\t}\r\n\t\tcnode = cnode.parent;\r\n\t}\r\n};\r\n\r\nconst nodeComparator = (a, b) => {\r\n\tif (a.fCost < b.fCost) return -1;\r\n\telse if (a.fCost > b.fCost) return 1;\r\n\telse if (a.hCost < b.hCost) return -1;\r\n\telse if (a.hCost > b.hCost) return 1;\r\n\t\r\n\treturn 0;\r\n};\r\n\r\nconst findPath = (startNode, endNode, gridDimensions) => {\r\n\t// TODO cache this\r\n\tconst nodeDist = makeNodeDistance(gridDimensions);\r\n\tconst step = makeAstarStep(nodeDist);\r\n\t\r\n\tlet openSet = new MinHeap(nodeComparator);\r\n\tlet closedSet = [];\r\n\t\r\n\topenSet.push(startNode);\r\n\t\r\n\twhile(openSet.size() > 0 && step(openSet, closedSet, endNode) !== 1);\r\n};\r\n\r\nconst findPathAndVisualize = (startNode, endNode, step) => {\r\n\tlet openSet = [];\r\n\tlet closedSet = [];\r\n\t\r\n\topenSet.push(startNode);\r\n\t\r\n\t// Todo: move coloring into this function, leave astarstep to do just that - step astar\r\n\tlet iid = setInterval(() => {\r\n\t\tconst res = step(openSet, closedSet, endNode, false);\r\n\t\tif (res === 1) {\r\n\t\t\tclearInterval(iid);\r\n\t\t}\r\n\t}, 10);\r\n};\r\n\r\n// Note that astarStep modifies openSet and closedSet. For complete functionalness, should return new copies.\r\nconst makeAstarStep = (nodeDistance) => {\r\n\treturn (openSet, closedSet, endNode, colorClosed = false) => {\r\n\t\t// Pick the node from the open set with the lowest f cost\r\n\t\tconst currentNode = openSet.pop();\r\n\t\tclosedSet.push(currentNode);\r\n\t\tif (colorClosed) {\r\n\t\t\tcurrentNode.cube.mat.color.set(0xff0000);\r\n\t\t}\r\n\t\t\r\n\t\tif (currentNode.id === endNode.id) {\r\n\t\t\tretracePath(currentNode);\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t\r\n\t\t// \r\n\t\tfor(let i = 0; i < currentNode.neighbours.length; i++) {\r\n\t\t\tconst neighbour = currentNode.neighbours[i];\r\n\t\t\t\r\n\t\t\t// No point looking at non-traversable nodes or those we already looked at. We could add a node id to make this less cumbersome.\r\n\t\t\tif (!neighbour.traversable || closedSet.find(e => e.id === neighbour.id)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst newDistanceToNeighbour = currentNode.gCost + nodeDistance(currentNode, neighbour);\r\n\t\t\tif (newDistanceToNeighbour < neighbour.gCost || !openSet.find(e => e.id === neighbour.id)) {\r\n\t\t\t\tneighbour.gCost = newDistanceToNeighbour;\r\n\t\t\t\tneighbour.hCost = nodeDistance(neighbour, endNode);\r\n\t\t\t\tneighbour.parent = currentNode;\r\n\t\t\t\t\r\n\t\t\t\tif (!openSet.find(e => e.id === neighbour.id)) {\r\n\t\t\t\t\topenSet.push(neighbour);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nexport default findPath;","F:\\GitHub\\astar\\astar-app\\src\\libs\\grid.js",["35"],"import * as THREE from 'three'\r\n\r\nlet GRID = {};\r\n\r\n// Utility functions for the grid\r\nGRID.selectRandomNode = (grid, condition) => {\r\n\tconst keys = Object.keys(grid.nodes);\r\n\tconst randomKey = keys[Math.floor(Math.random()*keys.length)];\r\n\tconst randomNode = grid.nodes[randomKey];\r\n\t\r\n\tif (condition && !condition(randomNode)) {\r\n\t\treturn this.selectRandomNode(grid, condition);\r\n\t}\r\n\treturn randomNode;\r\n}\r\n\r\nGRID.NODE_STATE = {\r\n\tTRAVERSABLE: 1,\r\n\tNON_TRAVERSABLE: 2,\r\n\tMARKED_GROUP: 3,\r\n\tMARKED_SINGLE: 4,\r\n\tSTART: 5,\r\n\tEND: 6,\r\n\tON_PATH: 7\r\n};\r\n\r\n// TODO: make the states all modifiable from the outside\r\nGRID.TRAVERSABLE_NODE_OPACITY = 0.1;\r\nGRID.OUTLINE_OPACITY = 0.2;\r\n\r\nconst isMarkedState = state => {\r\n\treturn state === GRID.NODE_STATE.MARKED_GROUP || state === GRID.NODE_STATE.MARKED_SINGLE;\r\n}\r\nGRID.setNodeState = (node, state) => {\r\n\tif (!node) {\r\n\t\treturn;\r\n\t}\r\n\t/*eslint no-fallthrough: [\"error\", { \"commentPattern\": \"break[\\\\s\\\\w]*omitted\" }]*/\r\n\tswitch(state) {\r\n\t\tcase GRID.NODE_STATE.NON_TRAVERSABLE:\r\n\t\t\tnode.traversable = false;\r\n\t\t\tnode.cube.mat.color.set(0xff0000);\r\n\t\t\tnode.cube.mat.opacity = 0.5;\r\n\t\t\tbreak;\r\n\t\tcase GRID.NODE_STATE.MARKED_GROUP:\r\n\t\t\tnode.cube.mat.color.set(0xa1a1a1);\r\n\t\t\tnode.cube.mat.opacity = 0.7;\r\n\t\t\tbreak;\r\n\t\tcase GRID.NODE_STATE.MARKED_SINGLE:\r\n\t\t\tnode.cube.mat.color.set(0x404040);\r\n\t\t\tnode.cube.mat.opacity = 0.9;\r\n\t\t\tbreak;\r\n\t\tcase GRID.NODE_STATE.START:\r\n\t\t\tnode.traversable = true;\r\n\t\t\tnode.cube.mat.color.set(0x0000ff);\r\n\t\t\tnode.cube.mat.opacity = 0.7;\r\n\t\t\tbreak;\r\n\t\tcase GRID.NODE_STATE.END:\r\n\t\t\tnode.traversable = true;\r\n\t\t\tnode.cube.mat.color.set(0xffff00);\r\n\t\t\tnode.cube.mat.opacity = 0.7;\r\n\t\t\tbreak;\r\n\t\tcase GRID.NODE_STATE.ON_PATH:\r\n\t\t\tnode.cube.mat.color.set(0x000000);\r\n\t\t\tnode.cube.mat.opacity = 0.9;\r\n\t\t\tbreak;\r\n\t\tcase GRID.NODE_STATE.TRAVERSABLE:\r\n\t\t\tnode.traversable = true;\r\n\t\t\tnode.cube.mat.color.set(0x00ff00);\r\n\t\t\tnode.cube.mat.opacity = GRID.TRAVERSABLE_NODE_OPACITY;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\treturn GRID.setNodeState(node, GRID.NODE_STATE.TRAVERSABLE);\r\n\t\t\t\r\n\t}\r\n\t\r\n\t// Allow state rollback, but do nothing between marked states\r\n\tif (isMarkedState(state) && isMarkedState(node.currentState)) {\r\n\t\treturn;\r\n\t}\r\n\tnode.previousState = node.currentState;\r\n\tnode.currentState = state;\r\n};\r\n\r\nGRID.resetNodeState = node => {\r\n\tGRID.setNodeState(node, node.previousState || GRID.NODE_STATE.TRAVERSABLE);\r\n}\r\n\r\nGRID.clearPathstate = node => {\r\n\tnode.parent = undefined;\r\n\tnode.gCost = 0;\r\n\tnode.hCost = 0;\r\n};\r\n\r\n// Internal functions\r\nconst createCube = (pos, ext) => {\r\n\tif (pos === undefined) {\r\n\t\tpos = [0, 0, 0];\r\n\t}\r\n\tif (ext === undefined) {\r\n\t\text = [1, 1, 1];\r\n\t}\r\n\t\r\n\tlet cube = {};\r\n\tcube.geo = new THREE.BoxGeometry();\r\n\tcube.mat = new THREE.MeshBasicMaterial({color: 0x00ff00 });\r\n\tcube.mat.opacity = 0.1;\r\n\tcube.mat.transparent = true;\r\n\tcube.mesh = new THREE.Mesh(cube.geo, cube.mat);\r\n\t\r\n\t// outline\r\n\tcube.outline = {};\r\n\tcube.outline.geo = new THREE.EdgesGeometry(cube.geo);\r\n\tcube.outline.mat = new THREE.MeshBasicMaterial({color: 0x000000 });\r\n\tcube.outline.mat.depthTest = false;\r\n\tcube.outline.mat.opacity = GRID.OUTLINE_OPACITY;\r\n\tcube.outline.mat.transparent = true;\r\n\tcube.outline.mesh = new THREE.LineSegments(cube.outline.geo, cube.outline.mat);\r\n\t\r\n\t// Properties to set position/scale simultaneously for outline and mesh\r\n\tcube.position = {};\r\n\tcube.position.set = (x, y, z) => {\r\n\t\tcube.mesh.position.set(x, y, z);\r\n\t\tcube.outline.mesh.position.set(x, y, z);\r\n\t\tcube.position.val = [x, y, z];\r\n\t};\r\n\tcube.position.get = () => cube.position.val;\r\n\t\r\n\tcube.scale = {};\r\n\tcube.scale.set = (x, y, z) => {\r\n\t\tcube.mesh.scale.set(x, y, z);\r\n\t\tcube.outline.mesh.scale.set(x, y, z);\r\n\t\tcube.scale.val = [x, y, z];\r\n\t};\r\n\tcube.scale.get = () => cube.scale.val;\r\n\t\r\n\tcube.scale.set(...ext);\r\n\tcube.position.set(...pos);\r\n\t\r\n\treturn cube;\r\n}\r\n\r\n// Node \"class\"\r\nconst createNode = cube => {\r\n\tlet node = {\r\n\t\ttraversable: true,\r\n\t\tcube: cube,\r\n\t\tid: JSON.stringify(cube.position.get()),\r\n\t\tneighbours: [],\r\n\t\tparent: undefined,\r\n\t\t// g-cost is the distance from the start node to the current node\r\n\t\tgCost: 0,\r\n\t\t// h-cost is the (approximate) distance from the current node to the end node\r\n\t\thCost: 0,\r\n\t\tfCost: function() { return this.gCost + this.hCost }\r\n\t};\r\n\t//node.fCost = () => node.gCost + node.hCost;\r\n\tGRID.setNodeState(node);\r\n\t\r\n\treturn node;\r\n}\r\n\r\n// Simple helpers to manipulate arrays. Does NOT work for b shorter than a\r\nconst addVec = (a, b) => a.map((v, i) => v + b[i]);\r\nconst subVec = (a, b) => a.map((v, i) => v - b[i]);\r\n\r\n// Create a grid centered at the origin.\r\n// Dimensions should contain sizeR, divR, with R = X, Y or Z. \r\n// If Z is not given, a 2D grid is constructed.\r\nGRID.create = dimensions => {\r\n\tconst nCubesX = dimensions.nCubesX;\r\n\tconst nCubesY = dimensions.nCubesY;\r\n\tconst nCubesZ = dimensions.nCubesZ;\r\n\t\r\n\t// Width of grid cubes in each dimension\r\n\tlet wx = dimensions.sizeX / nCubesX;\r\n\tlet wy = dimensions.sizeY / nCubesY;\r\n\tlet wz = dimensions.sizeZ / nCubesZ;\r\n\t\r\n\tconst ext = [wx, wy, wz];\r\n\t\r\n\t// Calculate center coordinates for each cube\r\n\tconst centerAndScaleRange = width => (val, idx, arr) => width*(val - Math.floor(arr.length/2) + 0.5*(1-arr.length%2));\r\n\t\r\n\tconst x = [...Array(nCubesX).keys()].map(centerAndScaleRange(wx));\r\n\tconst y = [...Array(nCubesY).keys()].map(centerAndScaleRange(wy));\r\n\tconst z = [...Array(nCubesZ).keys()].map(centerAndScaleRange(wz));\r\n\t\r\n\tconst cartesian = (...a) => a.reduce((a, b) => a.flatMap(d => b.map(e => [d, e].flat())));\r\n\tconst cubeCoords = cartesian(x, y, z);\r\n\t\r\n\t// Create the cubes\r\n\tlet cubes = cubeCoords.map(pos => createCube(pos, ext));\r\n\t\r\n\t// Create the grid, allowing indexing by position\r\n\tlet grid = {};\r\n\tgrid.nodes = {};\r\n\tcubes.forEach(cube => grid.nodes[JSON.stringify(cube.position.get())] = createNode(cube));\r\n\t\r\n\t// Add neighbours to each grid cell\r\n\tconst neighbourPositionsAndSelf = cartesian([-wx, 0, wx], [-wy, 0, wy], [-wz, 0, wz]);\r\n\t\r\n\t// The origin is no neighbour\r\n\tconst neighbourPositions = neighbourPositionsAndSelf.filter(nbpos => nbpos.reduce((a,cv) => Math.abs(a) + Math.abs(cv)) > 0);\r\n\t\r\n\t// TODO: this does not play well when sizex/ncubes arent integer multiples of each other\r\n\tconst addNeighbours = (grid, node) => {\r\n\t\t// Get relative neighbour positions\r\n\t\tconst nodePosition = node.cube.position.get();\r\n\t\tconst nodeNeighbourPositions = neighbourPositions.map(np => addVec(nodePosition, np));\r\n\t\t\r\n\t\t// Remove nodes that fall outside the grid\r\n\t\tconst isInside = (x, y, z) => Math.abs(x) <= dimensions.sizeX/2 && Math.abs(y) <= dimensions.sizeY/2 && Math.abs(z) <= dimensions.sizeZ/2;\r\n\t\tconst nodeNeighbourPositionsInside = nodeNeighbourPositions.filter(nbpos => isInside(...nbpos));\r\n\t\t\r\n\t\t// Add neighbours to node\r\n\t\tnode.neighbours = nodeNeighbourPositionsInside.map(pos => grid.nodes[JSON.stringify(pos)]);\r\n\t};\r\n\tObject.keys(grid.nodes).forEach(nodeKey => addNeighbours(grid, grid.nodes[nodeKey]));\r\n\t\r\n\t// Add to scene\r\n\t//cubes.forEach(cube => scene.add(cube.outline.mesh));\r\n\t//cubes.forEach(cube => scene.add(cube.mesh));\r\n\t\r\n\t// Store grid properties\r\n\tgrid.dimensions = dimensions;\r\n\tgrid.nodeExt = ext;\r\n\tgrid.nCubes = [nCubesX, nCubesY, nCubesZ];\r\n\t\r\n\treturn grid;\r\n}\r\n\r\n\t\r\n\r\nexport default GRID;","F:\\GitHub\\astar\\astar-app\\src\\libs\\heap.js",[],"F:\\GitHub\\astar\\astar-app\\src\\libs\\util.js",[],{"ruleId":"36","replacedBy":"37"},{"ruleId":"38","replacedBy":"39"},{"ruleId":"40","severity":1,"message":"41","line":3,"column":8,"nodeType":"42","messageId":"43","endLine":3,"endColumn":16},{"ruleId":"40","severity":1,"message":"44","line":10,"column":8,"nodeType":"42","messageId":"43","endLine":10,"endColumn":18},{"ruleId":"40","severity":1,"message":"45","line":4,"column":7,"nodeType":"42","messageId":"43","endLine":4,"endColumn":13},{"ruleId":"40","severity":1,"message":"46","line":93,"column":7,"nodeType":"42","messageId":"43","endLine":93,"endColumn":27},{"ruleId":"40","severity":1,"message":"47","line":196,"column":7,"nodeType":"42","messageId":"43","endLine":196,"endColumn":13},"no-native-reassign",["48"],"no-negated-in-lhs",["49"],"no-unused-vars","'ReactDOM' is defined but never used.","Identifier","unusedVar","'createHeap' is defined but never used.","'addVec' is assigned a value but never used.","'findPathAndVisualize' is assigned a value but never used.","'subVec' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]