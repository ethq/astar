[{"F:\\GitHub\\astar\\astar-app\\src\\index.js":"1","F:\\GitHub\\astar\\astar-app\\src\\components\\AstarGrid.component.js":"2","F:\\GitHub\\astar\\astar-app\\src\\libs\\astar.js":"3","F:\\GitHub\\astar\\astar-app\\src\\libs\\grid.js":"4","F:\\GitHub\\astar\\astar-app\\src\\libs\\heap.js":"5","F:\\GitHub\\astar\\astar-app\\src\\libs\\util.js":"6"},{"size":379,"mtime":1610028991050,"results":"7","hashOfConfig":"8"},{"size":15571,"mtime":1610092783674,"results":"9","hashOfConfig":"8"},{"size":4511,"mtime":1610026795721,"results":"10","hashOfConfig":"8"},{"size":8167,"mtime":1610092944367,"results":"11","hashOfConfig":"8"},{"size":1788,"mtime":1610026795721,"results":"12","hashOfConfig":"8"},{"size":583,"mtime":1610092193509,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1jpzm82",{"filePath":"16","messages":"17","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"18","messages":"19","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20","usedDeprecatedRules":"21"},{"filePath":"22","messages":"23","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"F:\\GitHub\\astar\\astar-app\\src\\index.js",[],"F:\\GitHub\\astar\\astar-app\\src\\components\\AstarGrid.component.js",["28"],"F:\\GitHub\\astar\\astar-app\\src\\libs\\astar.js",["29","30"],"import MinHeap from './heap.js'\r\n\r\n// Simple helpers to manipulate arrays. Does NOT work for b shorter than a\r\nconst addVec = (a, b) => a.map((v, i) => v + b[i]);\r\nconst subVec = (a, b) => a.map((v, i) => v - b[i]);\r\n\r\n// For A* we'd like to calculate distances the same way, no matter the dimensions of the grid\r\nconst makeNodeDistance = (dimensions) => {\r\n\t// Width of grid cubes in each dimension\r\n\tconst widths = [dimensions.sizeX / dimensions.nCubesX,\r\n\t\t\t\t\tdimensions.sizeY / dimensions.nCubesY,\r\n\t\t\t\t\tdimensions.sizeZ / dimensions.nCubesZ];\r\n\t\r\n\treturn (nodeA, nodeB) => {\r\n\t\tconst posA = nodeA.cube.position.get();\r\n\t\tconst posB = nodeB.cube.position.get();\r\n\t\t\r\n\t\t// Distances, with a unit between each adjacent grid cell\r\n\t\tlet dists = subVec(posA, posB).map((v,i) => Math.abs(v)/widths[i]);\r\n\t\t\r\n\t\t// Distances on our unit grid, scaled by a factor 10 to avoid decimals\r\n\t\tconst distDiag = 14;\r\n\t\tconst distDirect = 10;\r\n\t\t\r\n\t\t// Dimensions to preferentially reduce in. [0, 1, 2] <=> [x, y, z]. dimA reduced first, then dimB. last moves are done in a straight line in dimC\r\n\t\tconst dimA = 0;\r\n\t\tconst dimB = 2;\r\n\t\t//const dimC = 1;\r\n\t\t\r\n\t\tconst distDiagAB = Math.min(dists[dimA], dists[dimB]);\r\n\t\tconst distDirectAB = Math.abs(dists[dimA] - dists[dimB]);\r\n\t\t\r\n\t\t// The diagonal moves are removed from both dimensions\r\n\t\tdists[dimA] -= distDiagAB;\r\n\t\tdists[dimB] -= distDiagAB;\r\n\t\t\r\n\t\t// The direct moves are removed from the largest dimension\r\n\t\tif (dists[dimA] > dists[dimB]) {\r\n\t\t\tdists[dimA] -= distDirectAB;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdists[dimB] -= distDirectAB;\r\n\t\t}\r\n\t\t\r\n\t\t// At this point dist = [0, Y, 0]\r\n\t\tconst distDiagABC = Math.min(Math.max(dists[dimA], dists[dimB]));\r\n\t\tconst distDirectABC = Math.abs(dists.reduce((a, cv) => a - cv));\r\n\t\t\r\n\t\t/*\r\n\t\tconsole.log(distDiagAB);\r\n\t\tconsole.log(distDirectAB);\r\n\t\tconsole.log(distDiagABC);\r\n\t\tconsole.log(distDirectABC);\r\n\t\t*/\r\n\t\t\r\n\t\treturn distDiag*(distDiagAB + distDiagABC) + distDirect*(distDirectAB + distDirectABC);\r\n\t};\r\n};\r\n\r\n// Apply some action to each node on the path\r\nconst retracePath = (node, apply) => {\r\n\tlet cnode = node.parent;\r\n\twhile(cnode.parent) {\r\n\t\tif (apply) {\r\n\t\t\tapply(cnode);\r\n\t\t}\r\n\t\tcnode = cnode.parent;\r\n\t}\r\n};\r\n\r\nconst nodeComparator = (a, b) => {\r\n\tif (a.fCost < b.fCost) return -1;\r\n\telse if (a.fCost > b.fCost) return 1;\r\n\telse if (a.hCost < b.hCost) return -1;\r\n\telse if (a.hCost > b.hCost) return 1;\r\n\t\r\n\treturn 0;\r\n};\r\n\r\nconst findPath = (startNode, endNode, gridDimensions) => {\r\n\t// TODO cache this\r\n\tconst nodeDist = makeNodeDistance(gridDimensions);\r\n\tconst step = makeAstarStep(nodeDist);\r\n\t\r\n\tlet openSet = new MinHeap(nodeComparator);\r\n\tlet closedSet = [];\r\n\t\r\n\topenSet.push(startNode);\r\n\t\r\n\twhile(openSet.size() > 0 && step(openSet, closedSet, endNode) !== 1);\r\n};\r\n\r\nconst findPathAndVisualize = (startNode, endNode, step) => {\r\n\tlet openSet = [];\r\n\tlet closedSet = [];\r\n\t\r\n\topenSet.push(startNode);\r\n\t\r\n\t// Todo: move coloring into this function, leave astarstep to do just that - step astar\r\n\tlet iid = setInterval(() => {\r\n\t\tconst res = step(openSet, closedSet, endNode, false);\r\n\t\tif (res === 1) {\r\n\t\t\tclearInterval(iid);\r\n\t\t}\r\n\t}, 10);\r\n};\r\n\r\n// Note that astarStep modifies openSet and closedSet. For complete functionalness, should return new copies.\r\nconst makeAstarStep = (nodeDistance) => {\r\n\treturn (openSet, closedSet, endNode, colorClosed = false) => {\r\n\t\t// Pick the node from the open set with the lowest f cost\r\n\t\tconst currentNode = openSet.pop();\r\n\t\tclosedSet.push(currentNode);\r\n\t\tif (colorClosed) {\r\n\t\t\tcurrentNode.cube.mat.color.set(0xff0000);\r\n\t\t}\r\n\t\t\r\n\t\tif (currentNode.id === endNode.id) {\r\n\t\t\tretracePath(currentNode);\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t\t\r\n\t\t// \r\n\t\tfor(let i = 0; i < currentNode.neighbours.length; i++) {\r\n\t\t\tconst neighbour = currentNode.neighbours[i];\r\n\t\t\t\r\n\t\t\t// No point looking at non-traversable nodes or those we already looked at. We could add a node id to make this less cumbersome.\r\n\t\t\tif (!neighbour.traversable || closedSet.find(e => e.id === neighbour.id)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tconst newDistanceToNeighbour = currentNode.gCost + nodeDistance(currentNode, neighbour);\r\n\t\t\tif (newDistanceToNeighbour < neighbour.gCost || !openSet.find(e => e.id === neighbour.id)) {\r\n\t\t\t\tneighbour.gCost = newDistanceToNeighbour;\r\n\t\t\t\tneighbour.hCost = nodeDistance(neighbour, endNode);\r\n\t\t\t\tneighbour.parent = currentNode;\r\n\t\t\t\t\r\n\t\t\t\tif (!openSet.find(e => e.id === neighbour.id)) {\r\n\t\t\t\t\topenSet.push(neighbour);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nexport default findPath;",["31","32"],"F:\\GitHub\\astar\\astar-app\\src\\libs\\grid.js",["33"],"F:\\GitHub\\astar\\astar-app\\src\\libs\\heap.js",[],"F:\\GitHub\\astar\\astar-app\\src\\libs\\util.js",[],{"ruleId":"34","severity":1,"message":"35","line":3,"column":8,"nodeType":"36","messageId":"37","endLine":3,"endColumn":16},{"ruleId":"34","severity":1,"message":"38","line":4,"column":7,"nodeType":"36","messageId":"37","endLine":4,"endColumn":13},{"ruleId":"34","severity":1,"message":"39","line":93,"column":7,"nodeType":"36","messageId":"37","endLine":93,"endColumn":27},{"ruleId":"40","replacedBy":"41"},{"ruleId":"42","replacedBy":"43"},{"ruleId":"34","severity":1,"message":"44","line":196,"column":7,"nodeType":"36","messageId":"37","endLine":196,"endColumn":13},"no-unused-vars","'ReactDOM' is defined but never used.","Identifier","unusedVar","'addVec' is assigned a value but never used.","'findPathAndVisualize' is assigned a value but never used.","no-native-reassign",["45"],"no-negated-in-lhs",["46"],"'subVec' is assigned a value but never used.","no-global-assign","no-unsafe-negation"]